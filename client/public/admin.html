<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>게임 관리자</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            flex-direction: column;
            justify-content: flex-start;
            padding-top: 40px;
            background-color: #f4f4f9;
            height: auto;
        }

        h1 {
            color: #333;
        }

        .container {
            background-color: #fff;
            color: #333;
            min-width: 600px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .room-header {
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 10px;
            /* ★★★ 타이머와 헤더 정렬을 위해 추가 ★★★ */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* ★★★ 1. 타이머 디자인 개선 ★★★ */
        .admin-timer-display {
            font-size: 1.8em;
            /* 크기 증가 */
            font-weight: bold;
            color: #dc3545;
            /* 빨간색으로 시인성 확보 */
            border: 2px solid #dc3545;
            /* 테두리 */
            padding: 5px 10px;
            border-radius: 8px;
            min-width: 80px;
            /* 최소 너비 */
            text-align: center;
            background-color: #fff8f8;
            /* 아주 연한 빨간색 배경 */
            /* margin-left는 room-header의 justify-content로 대체 */
        }

        /* 타이머가 비어있을 때 (0:00 표시) */
        .admin-timer-display:empty::before {
            content: '0:00';
            color: #aaa;
            border-color: #ccc;
            background-color: #f9f9f9;
        }


        .room h2,
        .room h3 {
            color: #333;
        }

        .room h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .room li {
            background-color: #e9e9e9;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .room li.dead {
            color: #999;
            background-color: #ddd;
            text-decoration: line-through;
        }

        .role-info {
            font-weight: normal;
            color: #007bff;
        }

        .eliminate-btn,
        .revive-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            color: white;
        }

        .eliminate-btn {
            background-color: #dc3545;
        }

        .revive-btn {
            background-color: #28a745;
        }

        .start-game-btn,
        .next-phase-btn,
        .timer-btn,
        .trigger-alien-action-btn,
        .trigger-rampage-btn,
        .resolve-night-btn,
        .trigger-crew-action-btn,
        .end-night-btn,
        .start-nomination-btn,
        .start-ejection-minigame-btn,
        .resolve-ejection-minigame-btn,
        /* ★★★ 타이머 클래스명 변경 반영 ★★★ */
        .meeting-timer-btn,
        .escape-timer-btn {
            width: 100%;
            padding: 10px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
        }

        /* ★★★ 비활성화 버튼 스타일 추가 ★★★ */
        .start-game-btn:disabled,
        .next-phase-btn:disabled,
        .timer-btn:disabled,
        .trigger-alien-action-btn:disabled,
        .trigger-rampage-btn:disabled,
        .resolve-night-btn:disabled,
        .trigger-crew-action-btn:disabled,
        .end-night-btn:disabled,
        .start-nomination-btn:disabled,
        .start-ejection-minigame-btn:disabled,
        .resolve-ejection-minigame-btn:disabled,
        .meeting-timer-btn:disabled,
        .escape-timer-btn:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }


        .start-game-btn {
            background-color: #28a745;
        }

        .next-phase-btn {
            background-color: #007bff;
        }

        .timer-btn,
        .meeting-timer-btn,
        .escape-timer-btn {
            background-color: #ffc107;
            color: #212529;
        }

        .trigger-alien-action-btn,
        .trigger-rampage-btn {
            background-color: #6f42c1;
        }

        /* ★★★ 3. 여왕의 만찬 활성화 버튼 스타일 ★★★ */
        .trigger-rampage-btn.active {
            background-color: #4a2c82;
            /* 더 어두운 보라색 */
        }

        .resolve-night-btn {
            background-color: #fd7e14;
        }

        .trigger-crew-action-btn {
            background-color: #20c997;
        }

        .end-night-btn {
            background-color: #6c757d;
        }

        .role-settings,
        .preset-settings {
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }

        .role-item {
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .role-item span {
            font-weight: bold;
        }

        .role-controls input {
            width: 35px;
            padding: 5px;
        }

        .preset-select {
            width: 100%;
            padding: 8px;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .role-summary,
        .phase-info {
            font-weight: bold;
            margin-top: 10px;
        }

        .crisis-roulette-result-text {
            text-align: center;
            /* [최후의 사투] 텍스트 가운데 정렬 */
        }

        #reset-server-btn {
            width: auto;
            /* 너비를 자동으로 조절 */
            padding: 8px 16px;
            /* 내부 여백 축소 */
            font-size: 0.9em;
            /* 폰트 크기 축소 */
            margin-top: 10px;
            background-color: #6c757d;
            /* 회색 계열로 변경 */
        }

        #reset-server-btn:hover {
            background-color: #5a6268;
        }

        .admin-log-box {
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            padding: 10px;
            margin-top: 15px;
            height: 150px;
            /* 로그 박스 높이 고정 */
            overflow-y: auto;
            /* 내용이 높이를 넘어서면 자동으로 스크롤바 생성 */
            font-size: 0.9em;
            text-align: left;
            display: flex;
            flex-direction: column-reverse;
        }

        .admin-log-box p {
            margin: 2px 0;
            line-height: 1.4;
            color: #333;
        }

        /* admin.html 파일의 <style> 태그 맨 아래에 이 코드를 추가해주세요. */

        .room li {
            align-items: flex-start;
            /* 다중 라인 콘텐츠를 위해 상단 정렬로 변경 */
            padding: 12px;
        }

        .player-info-container {
            line-height: 1.5;
            /* 줄 간격을 적절하게 조정 */
        }

        .player-info-name {
            font-weight: bold;
            font-size: 1.05em;
            color: #333;
        }

        .player-info-group,
        .player-info-role {
            font-size: 0.9em;
            color: #555;
        }

        .admin-log-box p.log-mission_buff,
        .admin-log-box p.log-phase_change {
            color: #b08000;
            font-weight: bold;
            background-color: #fffbe6;
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* ★★★ 2. 역할별 색상 스타일 (기존 .important- 스타일 대체) ★★★ */
        .player-info-role.role-alien {
            color: #dc3545;
            /* 빨간색 (에일리언, 알, 여왕, 주술사) */
            font-weight: bold;
        }

        .player-info-role.role-core-crew {
            color: #007bff;
            /* 파란색 (함장, 엔지니어) */
            font-weight: bold;
        }

        .player-info-role.role-special-crew {
            color: #28a745;
            /* 초록색 (의사, 경호원, 초능력자, 수다쟁이, 군인, 신의 사도) */
            font-weight: bold;
        }

        /* '뚱이', '일반 승객'은 기본 회색으로 표시됩니다. */

        /* ★★★ [신규 추가] 1차 후보 지목 현황판 스타일 ★★★ */
        .vote-status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            /* 2열 -> 3열 그리드 */
            gap: 8px;
            list-style: none;
            padding: 0;
            margin-top: 10px;
        }

        .vote-status-item {
            font-size: 0.9em;
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            padding: 8px;
            border-radius: 4px;
        }

        .vote-status-item.voted {
            background-color: #e6ffed;
            /* 투표 완료 시 연한 초록색 */
            border-color: #b8e6c3;
        }

        .vote-status-item b {
            color: #0056b3;
            /* 투표자 이름 */
        }
    </style>
</head>

<body>
    <h1>에일리언 마피아 - 관리자 대시보드</h1>

    <div id="create-room-container" class="container" style="min-width: 600px; margin-bottom: 20px;">
        <h3>새로운 게임방 생성</h3>
        <input type="text" id="new-room-code-input" placeholder="사용할 초대 코드를 입력하세요"
            style="width: 60%; font-size: 1em; padding: 10px;">
        <button id="create-room-btn" style="width: auto; padding: 10px 20px; font-size: 1em; margin-left: 10px;">방
            생성</button>
    </div>
    <div id="game-rooms-container"></div>
    <div id="server-reset-container" class="container"
        style="min-width: 600px; margin-top: 30px; background-color: #5e2f35;">
        <h3 style="color: #ffc107;">서버 전체 초기화</h3>
        <p style="font-size: 0.9em; color: #eee;">
            주의: 이 버튼을 누르면 현재 진행 중이거나 대기 중인 모든 게임방의 정보가 영구적으로 삭제됩니다.
        </p>
        <button id="reset-server-btn" style="background-color: #dc3545; color: white;">모든 게임 기록 삭제</button>
    </div>
    <script>
        const socket = io();
        const roomsContainer = document.getElementById('game-rooms-container');
        document.getElementById('create-room-btn').addEventListener('click', () => {
            const codeInput = document.getElementById('new-room-code-input');
            const newCode = codeInput.value.trim();

            if (newCode) {
                socket.emit('createRoom', { code: newCode });
                codeInput.value = '';
            }
        });
        document.getElementById('reset-server-btn').addEventListener('click', () => {
            if (confirm('정말로 서버의 모든 게임 기록을 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.')) {
                socket.emit('resetServer');
            }
        });
        const ALL_ROLES = ['에일리언 여왕', '에일리언', '에일리언 알', '에일리언 주술사', '함장', '엔지니어', '의사', '경호원', '초능력자', '수다쟁이', '뚱이', '신의 사도', '군인', '일반 승객'];
        let gameRoomsState = {};
        let presetsState = {};
        let missionPresetsState = [];


        function getDefaultRoleCounts(playerCount) {
            const defaults = {
                '에일리언 여왕': 1,
                '에일리언': 1,
                '에일리언 알': 1,
                '에일리언 주술사': 1,
                '함장': 1,
                '엔지니어': 1,
                '의사': 4,
                '경호원': 1,
                '군인': 1,
                '초능력자': 1,
                '수다쟁이': 1,
                '뚱이': 1,
                '신의 사도': 1,
                '일반 승객': 6 // 나머지 인원을 일반 승객으로 채웁니다.
            };
            return defaults;
        }

        socket.on('connect', () => { socket.emit('adminConnect'); });

        socket.on('updateAdmin', (data) => {
            gameRoomsState = data.rooms;
            presetsState = data.presets ?? {};
            missionPresetsState = data.missionPresets || [];
            renderAdminView();
        });

        // ★★★ 신규 추가: 강제 방출 확인 요청 처리 ★★★
        socket.on('confirmForceEject', (data) => {
            const { playerIds, playerNames } = data;
            const roomDiv = document.querySelector('.room'); // 현재는 방이 하나만 있다는 가정
            const roomCode = roomDiv.dataset.code;

            if (confirm(`[${playerNames}] 님이(가) 카드를 선택하지 않았습니다. 이들을 즉시 방출시키겠습니까?`)) {
                socket.emit('forceEjectPlayers', { roomCode: roomCode, playerIds: playerIds });
            }
        });

        socket.on('adminError', (message) => {
            alert(message);
        });

        socket.on('crisisRouletteResult', (data) => {
            const { roomCode, result } = data;
            const roomElement = document.querySelector(`.room-item\[data-code="${roomCode}"]`);
            if (!roomElement) return;

            const crisisDisplay = roomElement.querySelector('.crisis-display');
            if (crisisDisplay) {
                crisisDisplay.innerHTML = `<div class="crisis-roulette-result-text">${result}</div>`;
                crisisDisplay.style.display = 'block';
                setTimeout(() => {
                    crisisDisplay.style.display = 'none';
                    const resolveButton = roomElement.querySelector('.resolve-escape-step-btn');
                    if (resolveButton) {
                        resolveButton.disabled = false;
                    }
                }, 2500);
            }
        });

        function renderAdminView() {
            const createRoomContainer = document.getElementById('create-room-container');

            roomsContainer.innerHTML = '';
            if (Object.keys(gameRoomsState).length === 0) {
                if (createRoomContainer) createRoomContainer.style.display = 'block';
                roomsContainer.innerHTML = '<p>아직 활성화된 게임방이 없습니다.</p>';
                return;
            } else {
                if (createRoomContainer) createRoomContainer.style.display = 'none';
            }

            for (const code in gameRoomsState) {
                const roomData = gameRoomsState[code];
                const roomDiv = document.createElement('div');
                roomDiv.className = 'room container';
                roomDiv.dataset.code = code;

                // --- 헤더 생성 (방 코드, 인원, 타이머) ---
                const headerDiv = document.createElement('div');
                headerDiv.className = 'room-header';
                const roomTitle = document.createElement('h2');
                roomTitle.textContent = `방 코드: ${code}`;

                const timerSpan = document.createElement('span');
                timerSpan.id = `timer-display-${code}`;
                timerSpan.className = 'admin-timer-display';

                const playerCountSpan = document.createElement('span');
                playerCountSpan.className = 'role-summary';
                playerCountSpan.textContent = `총 인원: ${roomData.players.length}명`;
                playerCountSpan.style.marginLeft = '20px';

                const titleAndCountDiv = document.createElement('div');
                titleAndCountDiv.style.display = 'flex';
                titleAndCountDiv.style.alignItems = 'center';
                titleAndCountDiv.appendChild(roomTitle);
                titleAndCountDiv.appendChild(playerCountSpan);

                headerDiv.appendChild(titleAndCountDiv);
                headerDiv.appendChild(timerSpan);
                roomDiv.appendChild(headerDiv);

                // --- 메인 콘텐츠 영역 ---
                const contentDiv = document.createElement('div');
                contentDiv.style.display = 'flex';
                contentDiv.style.gap = '20px';

                // =============================================
                // === 게임 대기 중 (waiting) 레이아웃 ========
                // =============================================
                if (roomData.status === 'waiting') {
                    // --- 대기실 3단 레이아웃 ---
                    const playerColumn = document.createElement('div');
                    playerColumn.style.flex = 5;
                    const gameSettingsColumn = document.createElement('div');
                    gameSettingsColumn.style.flex = 3;
                    const roleSettingsColumn = document.createElement('div');
                    roleSettingsColumn.style.flex = 2;

                    // --- 1열: 참가자 목록 ---
                    playerColumn.innerHTML = '<h3>참가자 목록</h3>';
                    const playerList = document.createElement('ul');
                    playerList.className = 'player-grid-list'; // 스타일 적용 위해 클래스 추가
                    roomData.players.forEach(player => {
                        const playerItem = document.createElement('li');
                        playerItem.style.justifyContent = 'space-between'; // 이름과 버튼 양쪽 정렬
                        const playerName = document.createElement('span');
                        playerName.textContent = player.name;
                        const kickButton = document.createElement('button');
                        kickButton.textContent = '퇴장';
                        kickButton.className = 'kick-btn'; // 스타일 적용
                        kickButton.dataset.playerId = player.id;
                        kickButton.dataset.playerName = player.name; // 확인 창에 이름 표시용
                        playerItem.appendChild(playerName);
                        playerItem.appendChild(kickButton);
                        playerList.appendChild(playerItem);
                    });
                    playerColumn.appendChild(playerList);

                    // --- 2열: 게임 설정 ---
                    gameSettingsColumn.innerHTML = '<h3>게임 설정</h3>';
                    // 도움말 박스
                    const helpBox = document.createElement('div');
                    helpBox.style.cssText = 'padding: 10px; margin-top: 15px; border: 1px solid #28a745; border-radius: 5px; background-color: #f8f9fa; text-align: left; color: #333;';
                    helpBox.innerHTML = '<b>[진행 가이드]</b> 모든 학생이 참가했는지 확인 후, 역할 인원을 맞추고 <b>\'게임 시작\'</b> 버튼을 누르세요.';
                    gameSettingsColumn.appendChild(helpBox);
                    // 미션 프리셋 설정
                    const missionPresetDiv = document.createElement('div');
                    missionPresetDiv.className = 'mission-preset-settings';
                    missionPresetDiv.style.marginTop = '15px';
                    missionPresetDiv.innerHTML = '<h4>미션 프리셋 설정</h4>';
                    if (missionPresetsState.length > 0) {
                        const presetSelect = document.createElement('select');
                        presetSelect.className = 'preset-select';
                        presetSelect.id = `mission-preset-select-${code}`;
                        missionPresetsState.forEach(presetName => {
                            const option = document.createElement('option');
                            option.value = presetName;
                            option.textContent = presetName;
                            presetSelect.appendChild(option);
                        });
                        presetSelect.selectedIndex = Math.floor(Math.random() * missionPresetsState.length); // 랜덤 선택
                        missionPresetDiv.appendChild(presetSelect);
                    } else {
                        missionPresetDiv.innerHTML += '<p>사용 가능한 미션 프리셋이 없습니다.</p>';
                    }
                    gameSettingsColumn.appendChild(missionPresetDiv);
                    // 방출 미니게임 토글
                    const minigameToggleDiv = document.createElement('div');
                    minigameToggleDiv.className = 'mission-preset-settings'; // 클래스 재활용
                    minigameToggleDiv.style.marginTop = '15px';
                    minigameToggleDiv.innerHTML = `
                        <h4>온라인 방출 미니게임</h4>
                        <label style="display: flex; align-items: center; justify-content: space-between; padding: 5px; background-color: #e9e9e9; border-radius: 4px;">
                            <span>미니게임 기능 사용 (ON/OFF)</span>
                            <input type="checkbox" class="ejection-minigame-toggle" id="ejection-minigame-toggle-${code}" checked>
                        </label>`;
                    gameSettingsColumn.appendChild(minigameToggleDiv);
                    // 모둠 수 설정
                    const groupSettingsDiv = document.createElement('div');
                    groupSettingsDiv.className = 'group-settings'; // CSS 적용 위해 클래스 추가
                    groupSettingsDiv.style.marginTop = '15px'; // 간격 추가
                    groupSettingsDiv.innerHTML = '<h4>모둠 수 설정</h4>';
                    const groupCountInput = document.createElement('input');
                    groupCountInput.type = 'number';
                    groupCountInput.className = 'group-count-input'; // CSS 적용 위해 클래스 추가
                    groupCountInput.style.width = '60px'; // 입력칸 크기 조절
                    groupCountInput.style.padding = '5px';
                    groupCountInput.id = `group-count-${code}`;
                    groupCountInput.value = roomData.groupCount || 6;
                    groupCountInput.min = 2; // 최소 2모둠
                    groupSettingsDiv.appendChild(groupCountInput);
                    gameSettingsColumn.appendChild(groupSettingsDiv);
                    // 게임 시작 버튼
                    const startButton = document.createElement('button');
                    startButton.className = 'start-game-btn'; // 스타일 적용
                    startButton.textContent = '게임 시작';
                    gameSettingsColumn.appendChild(startButton);

                    // --- 3열: 역할 인원 설정 ---
                    roleSettingsColumn.innerHTML = '<h3>역할 인원 설정</h3>';
                    // 총원 표시 헤더
                    const roleSettingsHeader = document.createElement('div');
                    roleSettingsHeader.style.display = 'flex';
                    roleSettingsHeader.style.justifyContent = 'space-between';
                    roleSettingsHeader.style.alignItems = 'center';
                    roleSettingsHeader.style.marginBottom = '10px';
                    const totalRolesSpan = document.createElement('span'); // 총원 표시될 span
                    totalRolesSpan.id = `total-roles-${code}`;
                    totalRolesSpan.style.fontWeight = 'bold';
                    roleSettingsHeader.appendChild(document.createTextNode('')); // 왼쪽 공간 차지 (flexbox 정렬용)
                    roleSettingsHeader.appendChild(totalRolesSpan);
                    roleSettingsColumn.appendChild(roleSettingsHeader);
                    // 역할 목록
                    const roleSettingsDiv = document.createElement('div');
                    roleSettingsDiv.className = 'role-settings'; // 스타일 적용
                    roleSettingsDiv.style.borderTop = 'none'; // 상단 구분선 제거 (이미 h3 아래 있음)
                    const currentCounts = (roomData.settings && Object.keys(roomData.settings).length > 1) ? roomData.settings : getDefaultRoleCounts(roomData.players.length);
                    let initialTotal = 0;
                    ALL_ROLES.forEach(roleName => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'role-item'; // 스타일 적용
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = roleName;
                        const controlsDiv = document.createElement('div');
                        controlsDiv.className = 'role-controls'; // 스타일 적용
                        const countInput = document.createElement('input');
                        countInput.type = 'number';
                        const currentRoleCount = currentCounts[roleName] || 0;
                        countInput.value = currentRoleCount;
                        initialTotal += currentRoleCount; // 초기 총원 계산
                        countInput.min = 0; // 0명 가능
                        countInput.dataset.role = roleName; // 역할 이름 저장
                        // 입력 시 총원 업데이트 이벤트 리스너
                        countInput.addEventListener('input', () => {
                            let currentTotal = 0;
                            const allInputs = roomDiv.querySelectorAll('.role-controls input');
                            allInputs.forEach(input => {
                                currentTotal += parseInt(input.value, 10) || 0;
                            });
                            totalRolesSpan.textContent = `총원: ${currentTotal}`;
                        });
                        controlsDiv.appendChild(countInput);
                        itemDiv.appendChild(nameSpan);
                        itemDiv.appendChild(controlsDiv);
                        roleSettingsDiv.appendChild(itemDiv);
                    });
                    totalRolesSpan.textContent = `총원: ${initialTotal}`; // 초기 총원 표시
                    roleSettingsColumn.appendChild(roleSettingsDiv);

                    // --- 최종 레이아웃 추가 ---
                    contentDiv.appendChild(playerColumn);
                    contentDiv.appendChild(gameSettingsColumn);
                    contentDiv.appendChild(roleSettingsColumn);

                    // =============================================
                    // === 게임 진행 중 (playing) 레이아웃 ========
                    // =============================================
                } else {
                    // --- 공통: 1열 (참가자 현황) 생성 ---
                    const playerColumn = document.createElement('div');
                    // 역할별 색상 정의
                    const ALIENS = ['에일리언 여왕', '에일리언', '에일리언 알', '에일리언 주술사'];
                    const CORE_CREW = ['함장', '엔지니어'];
                    const SPECIAL_CREW = ['의사', '경호원', '초능력자', '수다쟁이', '군인', '신의 사도'];
                    // 생존자 수 계산
                    const livingPlayersCount = roomData.players.filter(p => p.status === 'alive').length;
                    playerColumn.innerHTML = `<h3>참가자 현황 (${livingPlayersCount}/${roomData.players.length})</h3>`;
                    // 플레이어 목록 (ul)
                    const playerList = document.createElement('ul');
                    playerList.className = 'player-grid-list'; // 스타일 적용
                    // 플레이어 정렬 (중요 역할 우선)
                    const sortedPlayers = [...roomData.players].sort((a, b) => {
                        const getScore = (role) => {
                            if (ALIENS.includes(role)) return 3;
                            if (CORE_CREW.includes(role)) return 2;
                            if (SPECIAL_CREW.includes(role)) return 1;
                            return 0;
                        };
                        const scoreA = getScore(a.role);
                        const scoreB = getScore(b.role);
                        if (scoreA !== scoreB) return scoreB - scoreA;
                        return 0;
                    });
                    // 각 플레이어 정보 (li) 생성
                    sortedPlayers.forEach(player => {
                        const playerItem = document.createElement('li');
                        const playerInfoContainer = document.createElement('div');
                        playerInfoContainer.className = 'player-info-container';
                        // 이름
                        const nameLine = `<div class="player-info-name">${player.name}</div>`;
                        // 모둠
                        const groupText = player.group ? `${player.group}모둠` : '모둠 미정';
                        const groupLine = `<div class="player-info-group">${groupText}</div>`;
                        // 역할 (색상 적용)
                        let roleClass = 'player-info-role';
                        if (ALIENS.includes(player.role)) roleClass += ' role-alien';
                        else if (CORE_CREW.includes(player.role)) roleClass += ' role-core-crew';
                        else if (SPECIAL_CREW.includes(player.role)) roleClass += ' role-special-crew';
                        // 역할 텍스트 (추가 정보 포함)
                        let roleText = player.role || '역할 미정';
                        if (player.role === '경호원' && roomData.bodyguardProtection === player.id) {
                            const protectedPlayer = roomData.players.find(p => p.id === roomData.bodyguardProtection);
                            if (protectedPlayer) roleText += ` <span style="color: #28a745;">▶ ${protectedPlayer.name} 보호 중</span>`;
                        }
                        if (player.role === '에일리언 주술사' && roomData.selections && roomData.selections[player.id]) {
                            const cursedPlayer = roomData.players.find(p => p.id === roomData.selections[player.id]);
                            if (cursedPlayer) roleText += ` <span style="color: #6f42c1;">▶ ${cursedPlayer.name} 저주 중</span>`;
                        }
                        if ((player.role === '함장' || player.role === '군인') && typeof player.bullets !== 'undefined') {
                            roleText += ` (총알: ${player.bullets})`;
                        }
                        const roleLine = `<div class="${roleClass}">${roleText}</div>`;
                        // 정보 합치기
                        playerInfoContainer.innerHTML = nameLine + groupLine + roleLine;
                        playerItem.appendChild(playerInfoContainer);
                        // 사망/부활 버튼
                        if (player.status === 'dead') {
                            playerItem.classList.add('dead');
                            const reviveButton = document.createElement('button');
                            reviveButton.textContent = '처리 취소';
                            reviveButton.className = 'revive-btn';
                            reviveButton.dataset.playerId = player.id;
                            playerItem.appendChild(reviveButton);
                        } else {
                            const elimButton = document.createElement('button');
                            elimButton.textContent = '사망 처리';
                            elimButton.className = 'eliminate-btn';
                            elimButton.dataset.playerId = player.id;
                            playerItem.appendChild(elimButton);
                        }
                        playerList.appendChild(playerItem);
                    });
                    playerColumn.appendChild(playerList); // 플레이어 목록 추가
                    // 로그 박스
                    const logContainer = document.createElement('div');
                    logContainer.className = 'admin-log-box';
                    const gameLogHtml = (roomData.gameLog || []).map(logEntry => {
                        const text = typeof logEntry === 'string' ? logEntry : logEntry.text;
                        const type = typeof logEntry === 'string' ? 'log' : (logEntry.type || 'log');
                        return `<p class="log-${type}">${text}</p>`;
                    }).join('');
                    logContainer.innerHTML = gameLogHtml;
                    playerColumn.appendChild(logContainer); // 로그 박스 추가

                    // --- 공통: 2열 (게임 진행) 생성 ---
                    const settingsColumn = document.createElement('div');
                    settingsColumn.innerHTML = '<h3>게임 진행</h3>';
                    // 현재 상태 표시
                    const phaseInfo = document.createElement('div');
                    phaseInfo.className = 'phase-info';
                    let phaseText = `현재 상태: ${roomData.day}일차 ${roomData.phase}`;
                    if (roomData.pendingAction === 'engineer_choice') phaseText += ' (엔지니어 선택 대기중)';
                    else if (roomData.pendingAction === 'queen_rampage') phaseText += ' (여왕의 만찬 대기중)';
                    else if (roomData.pendingAction === 'crisis_roulette') phaseText += ' (위기 룰렛 대기중)';
                    else if (roomData.phase === 'escape_sequence') phaseText = '현재 상태: 비상탈출 시퀀스 진행 중';
                    phaseInfo.textContent = (roomData.status === 'game_over') ? `게임 종료 - ${roomData.winner} 승리` : phaseText;
                    settingsColumn.appendChild(phaseInfo);

                    // ★★★ 레이아웃 분기 ★★★
                    if (roomData.phase === 'meeting' && roomData.ejectionState === 'nominating') {
                        // --- A. 1차 후보 지목 중: 3단 레이아웃 ---
                        playerColumn.style.flex = 5; // 1열 너비
                        settingsColumn.style.flex = 2; // 2열 너비 (버튼 위주)
                        const voteStatusColumn = document.createElement('div'); // 3열 생성
                        voteStatusColumn.style.flex = 3; // 3열 너비

                        // 2열 (settingsColumn): 버튼과 도움말
                        if (roomData.status === 'playing') {
                            const helpBox = document.createElement('div');
                            helpBox.style.cssText = 'padding: 10px; margin-top: 15px; border: 1px solid #007bff; border-radius: 5px; background-color: #f8f9fa; text-align: left; color: #333;';
                            helpBox.innerHTML = '<b>[진행 가이드]</b> 모둠별 투표 현황을 확인하세요. 모두 투표하면 다음 단계 버튼이 활성화됩니다.';
                            settingsColumn.appendChild(helpBox);

                            const timerBtn = document.createElement('button');
                            timerBtn.className = 'timer-btn meeting-timer-btn';
                            timerBtn.textContent = '타이머 작동';
                            if (roomData.timeLeft > 0) {
                                timerBtn.textContent = '타이머 작동 중...';
                                timerBtn.disabled = true;
                            }
                            settingsColumn.appendChild(timerBtn);

                            // 지목 중 버튼 (비활성화 상태)
                            const nominatingBtn = document.createElement('button');
                            nominatingBtn.className = 'start-nomination-btn';
                            nominatingBtn.textContent = '1차 후보 지목 진행 중...';
                            nominatingBtn.disabled = true;
                            settingsColumn.appendChild(nominatingBtn);
                        }

                        // 3열 (voteStatusColumn): 투표 현황판
                        // 투표해야 하는 플레이어 목록 계산
                        const alivePlayers = roomData.players.filter(p => p.status === 'alive' && p.group);
                        const groupCounts = {};
                        alivePlayers.forEach(p => { groupCounts[p.group] = (groupCounts[p.group] || 0) + 1; });
                        const votersList = alivePlayers.filter(p => groupCounts[p.group] > 1); // 1명 모둠 제외
                        const totalVotersCount = votersList.length;
                        // 투표 완료 인원 계산
                        let votedCount = 0;
                        if (roomData.ejectionVotes) {
                            Object.values(roomData.ejectionVotes).forEach(groupVotes => {
                                votedCount += Object.keys(groupVotes).length;
                            });
                        }
                        // 제목 추가
                        const statusTitle = document.createElement('h3');
                        statusTitle.textContent = `1차 후보 지목 현황 (${votedCount}/${totalVotersCount})`;
                        voteStatusColumn.appendChild(statusTitle);
                        // 현황판 그리드 (ul)
                        const voteStatusGrid = document.createElement('ul');
                        voteStatusGrid.className = 'vote-status-grid'; // 스타일 적용
                        // 각 투표자 정보 (li) 생성
                        votersList.forEach(voter => {
                            const targetId = roomData.ejectionVotes?.[voter.group]?.[voter.id];
                            const voteStatusItem = document.createElement('li');
                            voteStatusItem.className = 'vote-status-item'; // 스타일 적용
                            if (targetId) { // 투표 완료
                                const targetPlayer = roomData.players.find(p => p.id === targetId);
                                const targetName = targetPlayer ? targetPlayer.name : '???';
                                voteStatusItem.innerHTML = `<b>${voter.name}</b> ▶ ${targetName}`;
                                voteStatusItem.classList.add('voted'); // 스타일 적용
                            } else { // 투표 중
                                voteStatusItem.innerHTML = `<b>${voter.name}</b>: (투표 중...)`;
                            }
                            voteStatusGrid.appendChild(voteStatusItem);
                        });
                        voteStatusColumn.appendChild(voteStatusGrid); // 3열에 현황판 추가

                        // 최종 3개 열 추가
                        contentDiv.appendChild(playerColumn);
                        contentDiv.appendChild(settingsColumn);
                        contentDiv.appendChild(voteStatusColumn);

                    } else {
                        // --- B. 그 외 모든 상황: 기존 2단 레이아웃 ---
                        playerColumn.style.flex = 6; // 1열 너비
                        settingsColumn.style.flex = 2; // 2열 너비

                        // 2열 (settingsColumn): 버튼, 도움말 등 기존 로직
                        if (roomData.status === 'playing') {
                            const helpBox = document.createElement('div');
                            helpBox.style.cssText = 'padding: 10px; margin-top: 15px; border: 1px solid #007bff; border-radius: 5px; background-color: #f8f9fa; text-align: left; color: #333;';
                            let helpText = ''; // 도움말 내용 (상황별로 다름)
                            // ... (기존 도움말 텍스트 설정 로직) ...
                            if (roomData.pendingAction === 'crisis_roulette') {
                                helpText = '<b>[진행 가이드]</b> 위기 상황 발생! 예상 결과를 확인하고 <b>[룰렛 시작]</b> 버튼을 누르세요.';
                            } else {
                                switch (roomData.phase) {
                                    case 'role_reveal': helpText = '<b>[진행 가이드]</b> 역할 확인 후 <b>\'1일차 회의 시작\'</b> 버튼 클릭.'; break;
                                    case 'meeting':
                                        if (roomData.settings.useEjectionMinigame) {
                                            if (roomData.ejectionState === 'pending_start') helpText = '<b>[진행 가이드]</b> 타이머 작동 후 <b>\'1차 후보 지목 시작\'</b> 클릭.';
                                            else if (roomData.ejectionState === 'minigame_pending') helpText = '<b>[진행 가이드]</b> 후보 확정! <b>\'방출 미니게임 시작\'</b> 클릭.';
                                            else if (roomData.ejectionState === 'minigame_active' || roomData.ejectionState === 'minigame_all_selected') helpText = '<b>[진행 가이드]</b> 후보들 선택 중. 모두 완료 시 <b>\'결과 공개\'</b> 클릭.';
                                            else helpText = '<b>[진행 가이드]</b> 회의 진행 중...';
                                        } else {
                                            helpText = '<b>[진행 가이드]</b> 타이머 후 토론/투표 진행. 완료 시 <b>\'밤으로 이동\'</b> 클릭.';
                                        }
                                        break;
                                    case 'night_alien_action': helpText = '<b>[진행 가이드]</b> (모두 엎드린 후) <b>\'에일리언 활동 시작\'</b> 클릭. 완료 시 <b>\'결과 반영\'</b> 클릭.'; break;
                                    case 'night_crew_action': helpText = '<b>[진행 가이드]</b> 탐사대 활동 안내 후 시간 부여. 완료 시 <b>\'다음날 이동\'</b> 클릭.'; break;
                                    default: helpText = '<b>[진행 가이드]</b> 다음 단계를 위해 아래 버튼 클릭.';
                                }
                            }
                            helpBox.innerHTML = helpText;
                            settingsColumn.appendChild(helpBox);

                            // --- 상황별 버튼 생성 ---
                            if (roomData.pendingAction === 'crisis_roulette') {
                                // 위기 룰렛 버튼
                                const crisis = roomData.crisis || {};
                                const crisisBtn = document.createElement('button');
                                crisisBtn.className = 'start-crisis-roulette-btn';
                                crisisBtn.textContent = `[${crisis.type || '위기'}] 룰렛 시작`;
                                crisisBtn.style.backgroundColor = '#6f42c1';
                                const resultText = document.createElement('p');
                                resultText.style.fontWeight = 'bold';
                                resultText.innerHTML = `(예상 결과: <span style="color: #dc3545;">${crisis.result || '알 수 없음'}</span>)`;
                                settingsColumn.appendChild(crisisBtn);
                                settingsColumn.appendChild(resultText);
                            } else if (roomData.phase === 'escape_sequence') {
                                // 비상 탈출 시퀀스 버튼
                                const escapeLogDiv = document.createElement('div');
                                escapeLogDiv.style.cssText = 'background-color: #222; color: lime; padding: 10px; border-radius: 5px; font-family: monospace; height: 150px; overflow-y: auto; margin-top: 15px;';
                                escapeLogDiv.innerHTML = (roomData.escapeLog || []).join('<br>');
                                settingsColumn.appendChild(escapeLogDiv);
                                const resolveStepBtn = document.createElement('button');
                                resolveStepBtn.className = 'resolve-escape-step-btn';
                                resolveStepBtn.textContent = `관문 ${roomData.escapeStep + 1}단계 확인`;
                                resolveStepBtn.style.cssText = 'background-color: #fd7e14; width: 100%; padding: 10px; margin-top: 15px; border:none; color:white; border-radius:5px; font-size:1em; cursor:pointer;';
                                settingsColumn.appendChild(resolveStepBtn);
                            } else if (roomData.pendingAction === 'engineer_choice') {
                                // 엔지니어 선택 대기 텍스트
                                const notice = document.createElement('p');
                                notice.textContent = '엔지니어가 [계속 싸운다] 또는 [비상탈출]을 선택하기를 기다리는 중입니다...';
                                notice.style.cssText = 'font-weight: bold; color: #007bff; margin-top: 15px;';
                                settingsColumn.appendChild(notice);
                            } else if (roomData.pendingAction === 'escape_vote_pending') {
                                // 비상탈출 최종 투표 시작 버튼
                                settingsColumn.innerHTML += `<p style="margin-top:15px;">모든 생존자가 역할 주장을 마쳤습니다.</p>`;
                                const startVoteBtn = document.createElement('button');
                                startVoteBtn.className = 'start-escape-vote-btn';
                                startVoteBtn.textContent = '최종 투표 시작';
                                startVoteBtn.style.backgroundColor = '#28a745';
                                settingsColumn.appendChild(startVoteBtn);
                            } else if (roomData.pendingAction === 'escape_survivor_selection') {
                                // 비상탈출 투표 현황 및 타이머/종료 버튼
                                const livingPlayersCountEsc = roomData.players.filter(p => p.status === 'alive').length;
                                const votedPlayersEsc = Object.keys(roomData.escapeVotes || {}).length;
                                settingsColumn.innerHTML += `<h4 style="margin-top:15px;">비상탈출 투표 진행 중 (${votedPlayersEsc}/${livingPlayersCountEsc})</h4>`;
                                const timerBtnEsc = document.createElement('button');
                                timerBtnEsc.className = 'escape-timer-btn';
                                timerBtnEsc.textContent = '3분 30초 타이머 시작';
                                if (roomData.timeLeft > 0) {
                                    timerBtnEsc.textContent = '타이머 작동 중...';
                                    timerBtnEsc.disabled = true;
                                }
                                settingsColumn.appendChild(timerBtnEsc);
                                const forceFailBtnEsc = document.createElement('button');
                                forceFailBtnEsc.className = 'force-escape-fail-btn';
                                forceFailBtnEsc.textContent = '시간 초과로 투표 종료';
                                forceFailBtnEsc.style.backgroundColor = '#dc3545';
                                settingsColumn.appendChild(forceFailBtnEsc);
                            } else if (roomData.pendingAction === 'escape_ready') {
                                // 최종 탑승자 명단 및 시퀀스 시작 버튼
                                const survivorNames = (roomData.escapees || []).map(p => `${p.name} (${p.role})`).join('<br>');
                                settingsColumn.innerHTML += `<h4 style="margin-top:15px;">최종 탑승자 명단</h4><div style="padding: 10px; background-color: #e9e9e9; border-radius: 5px; text-align: left; margin-bottom: 15px;">${survivorNames}</div>`;
                                const startEscapeBtn = document.createElement('button');
                                startEscapeBtn.className = 'start-escape-sequence-btn';
                                startEscapeBtn.textContent = '비상탈출 시퀀스 시작';
                                startEscapeBtn.style.backgroundColor = '#6f42c1';
                                settingsColumn.appendChild(startEscapeBtn);
                            } else if (roomData.pendingAction === 'queen_rampage') {
                                // 여왕의 만찬 시작/결과 버튼
                                if (!roomData.queenActionTaken) {
                                    const rampageBtn = document.createElement('button');
                                    rampageBtn.className = 'trigger-rampage-btn';
                                    if (roomData.rampageTriggered) {
                                        rampageBtn.textContent = '여왕이 만찬 대상을 선택 중...';
                                        rampageBtn.disabled = true;
                                        rampageBtn.classList.add('active');
                                    } else {
                                        rampageBtn.textContent = '(모두 엎드린 후 클릭) 여왕의 만찬 시작';
                                    }
                                    settingsColumn.appendChild(rampageBtn);
                                } else {
                                    const resolveBtn = document.createElement('button');
                                    resolveBtn.id = 'resolve-rampage-btn';
                                    resolveBtn.textContent = '여왕의 만찬 결과 적용';
                                    resolveBtn.className = 'resolve-night-btn';
                                    settingsColumn.appendChild(resolveBtn);
                                }
                            } else if (roomData.phase === 'role_reveal') {
                                // 1일차 회의 시작 버튼
                                const btn = document.createElement('button');
                                btn.className = 'next-phase-btn';
                                btn.dataset.phase = 'meeting';
                                btn.dataset.day = 1;
                                btn.textContent = '1일차 회의 시작';
                                settingsColumn.appendChild(btn);
                            } else if (roomData.phase === 'meeting') {
                                // 회의 타이머 버튼
                                const timerBtn = document.createElement('button');
                                timerBtn.className = 'timer-btn meeting-timer-btn';
                                timerBtn.textContent = '타이머 작동';
                                if (roomData.timeLeft > 0) {
                                    timerBtn.textContent = '타이머 작동 중...';
                                    timerBtn.disabled = true;
                                }
                                settingsColumn.appendChild(timerBtn);
                                // 미니게임 ON/OFF 분기
                                if (roomData.settings.useEjectionMinigame) {
                                    // 상태별 버튼 표시 (지목 시작, 미니게임 시작, 결과 공개)
                                    switch (roomData.ejectionState) {
                                        case 'pending_start':
                                            const startNominationBtn = document.createElement('button');
                                            startNominationBtn.className = 'start-nomination-btn';
                                            startNominationBtn.textContent = '1차 후보 지목 시작';
                                            startNominationBtn.style.backgroundColor = '#fd7e14';
                                            settingsColumn.appendChild(startNominationBtn);
                                            break;
                                        // nominating 상태는 3단 레이아웃으로 처리되므로 여기서는 버튼 없음
                                        case 'minigame_pending':
                                            const startMinigameBtn = document.createElement('button');
                                            startMinigameBtn.className = 'start-ejection-minigame-btn';
                                            startMinigameBtn.textContent = '방출 미니게임 시작';
                                            startMinigameBtn.style.backgroundColor = '#6f42c1';
                                            settingsColumn.appendChild(startMinigameBtn);
                                            break;
                                        case 'minigame_active':
                                        case 'minigame_all_selected':
                                            const resolveBtn = document.createElement('button');
                                            resolveBtn.className = 'resolve-ejection-minigame-btn';
                                            resolveBtn.style.backgroundColor = '#dc3545';
                                            if (roomData.ejectionState === 'minigame_all_selected') {
                                                resolveBtn.textContent = '결과 공개 및 방출 실행';
                                                resolveBtn.disabled = false;
                                            } else {
                                                resolveBtn.textContent = '후보들 선택 중...';
                                                resolveBtn.disabled = true;
                                            }
                                            settingsColumn.appendChild(resolveBtn);
                                            break;
                                    }
                                } else {
                                    // 미니게임 OFF: 밤으로 이동 버튼
                                    const nextBtn = document.createElement('button');
                                    nextBtn.className = 'next-phase-btn';
                                    nextBtn.dataset.phase = 'night_alien_action';
                                    nextBtn.dataset.day = roomData.day;
                                    nextBtn.textContent = '밤으로 이동';
                                    settingsColumn.appendChild(nextBtn);
                                }
                            } else if (roomData.phase === 'night_alien_action') {
                                // 에일리언 활동 시작/결과 버튼
                                if (roomData.alienActionTriggered) {
                                    const resolveBtn = document.createElement('button');
                                    resolveBtn.className = 'resolve-night-btn';
                                    resolveBtn.textContent = '결과반영 및 탐사대 활동 시작';
                                    settingsColumn.appendChild(resolveBtn);
                                } else {
                                    const triggerBtn = document.createElement('button');
                                    triggerBtn.className = 'trigger-alien-action-btn';
                                    triggerBtn.textContent = '(모두 엎드린 후 클릭) 에일리언 활동 시작';
                                    settingsColumn.appendChild(triggerBtn);
                                }
                            } else if (roomData.phase === 'night_crew_action') {
                                // 다음날 이동 버튼
                                const endBtn = document.createElement('button');
                                endBtn.className = 'end-night-btn';
                                endBtn.textContent = '탐사대 활동 중 (다음날로 이동하려면 클릭)';
                                settingsColumn.appendChild(endBtn);
                            }
                        } // end if (roomData.status === 'playing')

                        // 최종 2개 열 추가
                        contentDiv.appendChild(playerColumn);
                        contentDiv.appendChild(settingsColumn);
                    } // end else (2단 레이아웃)
                } // end else (게임 시작 후)

                // --- 최종 contentDiv를 roomDiv에 추가 ---
                roomDiv.appendChild(contentDiv);
                // --- 최종 roomDiv를 roomsContainer에 추가 ---
                roomsContainer.appendChild(roomDiv);

            } // end for loop (gameRoomsState)
        } // end renderAdminView function

        // ★★★ [수정] 관리자용 타이머 업데이트 이벤트 리스너 ★★★
        socket.on('timerUpdate', (data) => {
            const { roomCode, timeLeft } = data;
            const timerDisplay = document.getElementById(`timer-display-${roomCode}`);

            if (timerDisplay) {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = (timeLeft % 60).toString().padStart(2, '0');
                timerDisplay.textContent = (timeLeft >= 0) ? `${minutes}:${seconds}` : "시간 종료!";
            }

            // ★★★ 4. 타이머 버튼 비활성화 로직 추가 ★★★
            const roomDiv = document.querySelector(`.room[data-code="${roomCode}"]`);
            if (roomDiv) {
                // 회의 타이머 버튼
                const timerBtn = roomDiv.querySelector('.meeting-timer-btn');
                if (timerBtn) {
                    if (timeLeft > 0) {
                        timerBtn.textContent = '타이머 작동 중...';
                        timerBtn.disabled = true;
                    } else {
                        // 타이머가 종료되면 버튼을 다시 활성화 (하지만 보통은 다음 단계로 넘어가서 버튼이 사라짐)
                        timerBtn.textContent = '타이머 작동';
                        timerBtn.disabled = false;
                    }
                }

                // 비상탈출 타이머 버튼
                const escapeTimerBtn = roomDiv.querySelector('.escape-timer-btn');
                if (escapeTimerBtn) {
                    if (timeLeft > 0) {
                        escapeTimerBtn.textContent = '타이머 작동 중...';
                        escapeTimerBtn.disabled = true;
                    } else {
                        escapeTimerBtn.textContent = '3분 30초 타이머 시작';
                        escapeTimerBtn.disabled = false;
                    }
                }
            }
        });

        roomsContainer.addEventListener('click', (event) => {
            const target = event.target;
            const roomDiv = target.closest('.room');
            if (!roomDiv) return;

            const roomCode = roomDiv.dataset.code;
            const classList = target.classList;

            if (classList.contains('meeting-timer-btn')) {
                socket.emit('startMeetingTimer', roomCode);
            }

            if (classList.contains('start-game-btn')) {
                const players = gameRoomsState[roomCode].players;
                if (players.length < 4) { return alert(`최소 인원(4명)이 모이지 않아 시작할 수 없습니다.`); }

                const roleSettings = {};
                let totalRoles = 0;
                const roleItems = roomDiv.querySelectorAll('.role-controls input');
                roleItems.forEach(input => {
                    const roleName = input.dataset.role;
                    const roleCount = parseInt(input.value, 10);
                    if (roleCount > 0) roleSettings[roleName] = roleCount;
                    totalRoles += roleCount;
                });

                if (totalRoles > 0 && totalRoles !== players.length) {
                    return alert('설정된 역할의 합계가 총 플레이어 수와 일치하지 않습니다.');
                }

                const groupCountInput = document.getElementById(`group-count-${roomCode}`);
                const presetSelect = document.getElementById(`mission-preset-select-${roomCode}`);
                const useEjectionMinigame = document.getElementById(`ejection-minigame-toggle-${roomCode}`).checked;


                socket.emit('startGame', {
                    code: roomCode,
                    settings: roleSettings,
                    groupCount: parseInt(groupCountInput.value, 10) || 4,
                    selectedPreset: presetSelect.value,
                    useEjectionMinigame: useEjectionMinigame
                });
            }
            else if (classList.contains('start-nomination-btn')) {
                const roomData = gameRoomsState[roomCode];
                const unselectedPlayers = roomData.players.filter(p => p.status === 'alive' && !p.group);

                if (unselectedPlayers.length > 0) {
                    const unselectedNames = unselectedPlayers.map(p => p.name).join(', ');
                    alert(`아직 모둠을 선택하지 않은 참가자가 있습니다: ${unselectedNames}`);
                } else {
                    if (confirm('모든 참가자에게 후보 지목 화면을 띄웁니다. 진행할까요?')) {
                        socket.emit('startEjectionNomination', { code: roomCode });
                    }
                }
            }
            else if (classList.contains('start-ejection-minigame-btn')) {
                const roomData = gameRoomsState[roomCode];

                const unvotedPlayerNames = [];
                const alivePlayers = roomData.players.filter(p => p.status === 'alive' && p.group);

                const alivePlayerGroups = new Set(alivePlayers.map(p => p.group));

                alivePlayerGroups.forEach(groupNum => {
                    const groupMembers = alivePlayers.filter(p => p.group === groupNum);
                    // 1명 모둠은 투표 대상이 아니므로 제외
                    if (groupMembers.length > 1) {
                        groupMembers.forEach(member => {
                            // 해당 모둠의 투표 정보가 없거나, 있어도 해당 멤버의 투표 정보가 없으면
                            if (!roomData.ejectionVotes?.[groupNum]?.[member.id]) {
                                unvotedPlayerNames.push(member.name);
                            }
                        });
                    }
                });

                if (unvotedPlayerNames.length > 0) {
                    alert(`아직 다음 참가자가 후보를 지목하지 않았습니다:\n[${unvotedPlayerNames.join(', ')}]`);
                    return; // 팝업만 띄우고 함수 종료
                }
                // ★★★ 여기까지 ★★★

                if (confirm('모든 참가자에게 방출 미니게임을 시작합니다. 진행할까요?')) {
                    socket.emit('startEjectionMinigame', { code: roomCode });
                }
            }

            else if (classList.contains('resolve-ejection-minigame-btn')) {
                if (confirm('결과를 공개하고 방출자를 확정하시겠습니까?\n(선택하지 않은 후보가 있으면 강제 방출 여부를 다시 묻습니다.)')) {
                    socket.emit('resolveEjectionMinigame', { code: roomCode });
                }
            }
            else if (classList.contains('trigger-rampage-btn')) {
                socket.emit('triggerQueenRampage', { code: roomCode });
            }
            else if (target.id === 'resolve-rampage-btn') {
                socket.emit('resolveQueenRampage', { code: roomCode });
            }
            else if (classList.contains('eliminate-btn')) {
                if (confirm('정말로 이 플레이어를 사망 처리하시겠습니까?')) {
                    socket.emit('eliminatePlayer', { roomCode, playerId: target.dataset.playerId, cause: 'admin_action' });
                }
            } else if (classList.contains('revive-btn')) {
                if (confirm('정말로 이 처리를 취소하고 플레이어를 부활시키겠습니까?')) {
                    socket.emit('revivePlayer', { roomCode, playerId: target.dataset.playerId });
                }
            } else if (classList.contains('next-phase-btn')) {
                socket.emit('nextPhase', { code: roomCode, phase: target.dataset.phase, day: target.dataset.day });
            } else if (classList.contains('trigger-alien-action-btn')) {
                socket.emit('triggerAlienAction', { code: roomCode });
            } else if (classList.contains('resolve-night-btn')) {
                socket.emit('resolveNightActions', { code: roomCode });
            } else if (classList.contains('trigger-crew-action-btn')) {
                socket.emit('triggerCrewAction', { code: roomCode });
            } else if (classList.contains('end-night-btn')) {
                socket.emit('endNightAndStartMeeting', { code: roomCode });
            } else if (classList.contains('start-escape-vote-btn')) {
                if (confirm('모든 생존자에게 투표 화면을 띄웁니다. 진행할까요?')) {
                    socket.emit('startEscapeVote', { code: roomCode });
                }
            } else if (classList.contains('start-escape-sequence-btn')) {
                const roomData = gameRoomsState[roomCode];
                const survivorIds = (roomData.escapees || []).map(p => p.id);
                if (survivorIds.length !== 4) {
                    return alert('오류: 최종 탑승자가 4명이 아닙니다. 투표가 잘못된 것 같습니다.');
                }
                socket.emit('startEscapeSequence', { code: roomCode, survivorIds: survivorIds });

            } else if (classList.contains('escape-timer-btn')) {
                socket.emit('startEscapeTimer', roomCode);
                target.textContent = '타이머 작동 중...';
                target.disabled = true;
            } else if (classList.contains('force-escape-fail-btn')) {
                if (confirm('정말로 시간 초과로 비상탈출을 실패 처리하시겠습니까?')) {
                    socket.emit('forceEscapeFailure', { code: roomCode });
                }
            } else if (classList.contains('resolve-escape-step-btn')) {
                socket.emit('resolveEscapeStep', { code: roomCode });
            } else if (classList.contains('start-crisis-roulette-btn')) {
                const crisis = gameRoomsState[roomCode]?.crisis;
                const crisisType = crisis ? `[${crisis.type}]` : '';
                if (confirm(`${crisisType} 룰렛을 시작하면 모든 참가자에게 결과가 공개됩니다. 정말 진행하시겠습니까?`)) {
                    socket.emit('startCrisisRoulette', { roomCode });
                }
            } else if (classList.contains('kick-btn')) {
                const playerName = target.dataset.playerName;
                if (confirm(`정말로 '${playerName}' 님을 대기실에서 퇴장시키겠습니까?`)) {
                    socket.emit('kickPlayer', { roomCode, playerId: target.dataset.playerId });
                }
            }
        });
    </script>
</body>

</html>