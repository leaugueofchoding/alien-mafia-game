<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>에일리언 마피아 게임</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link rel="stylesheet" href="style.css">

    <style>
        .typing-cursor {
            display: inline-block;
            width: 10px;
            height: 1.2em;
            background-color: #00ff41;
            animation: blink 1s step-end infinite;
            vertical-align: bottom;
        }

        .group-info-header {
            background-color: rgba(0, 209, 255, 0.1);
            border: 1px solid #00d1ff;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 8px;
            text-align: left;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div id="root">
        <div id="player-container" class="container" style="display: block;">
            <div id="initial-screen">
                <h2>플레이어로 참가</h2>
                <input type="text" id="name-input" placeholder="이름을 입력하세요">
                <input type="text" id="code-input" placeholder="초대 코드">
                <button id="join-button">게임 참가</button>
            </div>
        </div>
        <div id="admin-container" class="container">
            <h2>관리자 모드</h2>
            <button id="admin-button" class="admin-button">관리자 페이지로 이동</button>
        </div>
    </div>

    <script>
        let currentTab = 'ability'; // 기본값: '내 능력' 탭
        const socket = io();
        const rootDiv = document.getElementById('root');
        const playerContainer = document.getElementById('player-container');
        const adminContainer = document.getElementById('admin-container');

        let amIAlive = true;
        let huntSelections = [];
        let displayedLogCount = 0;
        let currentRoomCode = '';
        let gameRoomsState = {}; // 게임 전체 상태를 저장할 변수

        function clearContainer() {
            playerContainer.innerHTML = '';
            adminContainer.style.display = 'none';
            playerContainer.style.display = 'block';

            const rouletteOverlay = document.getElementById('roulette-overlay');
            if (rouletteOverlay) {
                rouletteOverlay.remove();
            }
        }
        function showInitialScreen() {
            playerContainer.style.display = 'block';
            playerContainer.innerHTML = `
            <div id="initial-screen">
                <h2>플레이어로 참가</h2>
                <input type="text" id="name-input" placeholder="이름을 입력하세요">
                <input type="text" id="code-input" placeholder="초대 코드">
                <button id="join-button">게임 참가</button>
            </div>`;
            adminContainer.style.display = 'block';
        }

        function showLobby(room, container, options = {}) {
            const targetContainer = container || playerContainer;
            const { showGroup = true } = options;

            const playerList = room.players.map(player => {
                let revealedClass = '';
                if (player.revealedRole) {
                    revealedClass = player.revealedBy === 'psychic' ? 'role-revealed-psychic' : 'role-revealed';
                }

                const revealedRole = player.revealedRole ? ` (${player.revealedRole})` : '';
                const groupInfo = showGroup && player.group ? ` (${player.group}모둠)` : '';

                return `<li class="${player.status === 'dead' ? 'dead' : ''} ${revealedClass}">
                    ${player.name}${groupInfo}${revealedRole}
                </li>`;
            }).join('');

            targetContainer.innerHTML = `
        <h2>참가자 목록</h2>
        <ul class="player-grid-list">${playerList}</ul>
    `;
        }

        function showRoleScreen(role, description) {
            clearContainer();
            playerContainer.innerHTML = `
                <h2>당신의 역할은...</h2>
                <h1 style="color: #ff4757;">${role}</h1>
                <p>${description}</p>`;
        }

        function showMeetingScreen(roomData, player) {
            let groupSelectionHtml = '';

            const guideText = roomData.day > 1
                ? `모둠을 이동한 뒤 해당 모둠 번호를 선택하세요.<br><small style="color: #ffc107;">신중하게 확인하세요. 모든 불이익은 자신의 책임입니다.</small>`
                : `현재 자신의 모둠 번호를 선택하세요.`;

            if (roomData.needsGroupSelection && !player.group) {
                const groupCount = roomData.groupCount || 4;
                let buttonsHtml = '';
                for (let i = 1; i <= groupCount; i++) {
                    buttonsHtml += `<button class="group-select-btn" data-group="${i}">${i}모둠</button>`;
                }
                groupSelectionHtml = `
            <div id="group-selection-container">
                <h3>${guideText}</h3>
                <div class="button-group" style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                    ${buttonsHtml}
                </div>
            </div>
            <hr>`;
            }

            playerContainer.innerHTML = `
        <h2>${roomData.day}일차 - 회의</h2>
        ${groupSelectionHtml}
        <p>생존자들과 토론하여 에일리언을 찾아내세요. 잠시 후 투표가 진행됩니다.</p>
        <h1 class="timer" id="timer-display"></h1>`;
        }

        function showAlienNightScreen(text = "에일리언이 활동을 시작합니다.") {
            clearContainer();
            playerContainer.innerHTML = `
                <h2>밤이 되었습니다.</h2>
                <p>모든 플레이어는 눈을 감아주세요. ${text}</p>`;
        }

        function showQueenHuntScreen(otherAliens, targets) {
            clearContainer();
            huntSelections = [];
            const targetButtons = targets.map(target => `<li><button class="target-btn" data-ability="queen_hunt" data-target-id="${target.id}">${target.name}</button></li>`).join('');
            playerContainer.innerHTML = `
                <h2>[사냥] 대상을 2명 선택하세요.</h2>
                <p>(단 한 번만 사용할 수 있는 강력한 능력입니다.)</p>
                <p>${otherAliens.length > 0 ? `(동료 에일리언: ${otherAliens.join(', ')})` : ''}</p>
                <ul class="player-grid-list">${targetButtons}</ul>
                <button id="confirm-hunt-btn" disabled>선택 완료 (0/2)</button>
            `;
        }

        function showQueenRampageScreen(targets) {
            clearContainer();
            huntSelections = [];
            const targetButtons = targets.map(target => `<li><button class="target-btn" data-ability="queen_rampage" data-target-id="${target.id}">${target.name}</button></li>`).join('');
            playerContainer.innerHTML = `
        <h2>[여왕의 만찬]</h2>
        <p>(분노에 휩싸여 최대 4명의 대상을 공격합니다. 대상을 선택하지 않을 수도 있습니다.)</p>
        <ul class="player-grid-list">${targetButtons}</ul>
        <button id="confirm-rampage-btn">선택 완료 (0명)</button>
    `;
        }

        function showDeathScreen() {
            clearContainer();
            playerContainer.innerHTML = `
                <h1 style="color: #dc3545;">당신은 사망하였습니다</h1>
                <p>조용히 사망자 구역으로 이동해주세요.</p>`;
        }

        function showGameOverScreen(data) {
            clearContainer();
            const detailLogHtml = data.detailLog ? `<p style="font-size: 1.2em; color: #ffc107;">${data.detailLog}</p>` : '';

            playerContainer.innerHTML = `
                <h1 class="game-over-title">${data.winner}의 승리!</h1>
                ${detailLogHtml}
                <p class="game-over-reason">${data.reason}</p>`;
        }

        // index.html 파일의 <script> 태그 안
        // ★★★ 기존 showCrewActionScreen 함수를 아래 코드로 통째로 교체해주세요. ★★★
        function showCrewActionScreen(room) {
            clearContainer();
            const me = room.players.find(p => p.id === socket.id);
            if (!me) return;

            let abilityContent = '';
            const isAlienTeam = me.role.includes('에일리언');

            if (!room.crewActionTriggered) {
                const message = isAlienTeam
                    ? "탐사대가 혼란에 빠진 틈을 타 미션을 방해하고 생존자들을 처리하세요."
                    : "밤이 깊었습니다. 동료들과 협력하여 미션을 해결하고 능력을 사용하세요!";
                abilityContent = `<div style="padding: 20px;"><h4>활동 대기중...</h4><p style="font-size: 1.1em; margin-top: 15px;">${message}</p><p style="margin-top: 10px;">관리자가 활동을 시작하기를 기다립니다.</p></div>`;
            } else {
                if (me.role === '함장' && me.bullets > 0) {
                    const targets = room.players.filter(p => p.status === 'alive' && p.id !== me.id);
                    abilityContent = `<h4>즉결 처분할 대상을 선택하세요. <span style="font-weight:normal;">(남은 총알: ${me.bullets}발)</span></h4><ul class="player-grid-list">${targets.map(t => `<li><button class="target-btn" data-ability="captain" data-target-id="${t.id}">${t.name}</button></li>`).join('')}</ul>`;
                } else if (me.role === '군인' && me.bullets > 0) {
                    const targets = room.players.filter(p => p.status === 'alive' && p.id !== me.id);
                    abilityContent = `<h4>저격할 대상을 선택하세요. <span style="font-weight:normal;">(남은 총알: ${me.bullets}발)</span></h4><ul class="player-grid-list">${targets.map(t => `<li><button class="target-btn" data-ability="soldier" data-target-id="${t.id}">${t.name}</button></li>`).join('')}</ul>`;
                } else if (me.role === '수다쟁이' && me.abilityUsedDay !== room.day) {
                    const targets = room.players.filter(p => p.status === 'alive' && p.id !== me.id);
                    abilityContent = `<h4>역할을 폭로할 대상을 선택하세요.</h4><p>(선택된 대상의 역할은 다음날부터 모두에게 공개됩니다.)</p><ul class="player-grid-list">${targets.map(t => `<li><button class="target-btn" data-ability="chatterbox" data-target-id="${t.id}">${t.name}</button></li>`).join('')}</ul>`;
                } else if (me.role === '초능력자' && !me.abilityUsed) {
                    const targets = room.players.filter(p => p.status === 'alive' && p.id !== me.id);
                    abilityContent = `<h4>정체를 꿰뚫어볼 대상 4명을 선택하세요.</h4><p>(단 한 번만 사용 가능하며, 실패 시 큰 위험이 따릅니다.)</p><ul class="player-grid-list">${targets.map(t => `<li><button class="target-btn" data-ability="psychic" data-target-id="${t.id}">${t.name}</button></li>`).join('')}</ul><button id="confirm-psychic-ability" disabled>선택 완료 (0/4)</button>`;
                } else if (me.role === '에일리언 알' && room.day === 3 && !me.abilityUsed) {
                    abilityContent = `<h4>알에서 깨어날 시간입니다...</h4><p>(룰렛 결과에 따라 '부화'하여 동료가 되거나, 주변을 '오염'시켜 적을 제거합니다.)</p><button id="start-hatch-btn" class="target-btn" style="width: 100%; background-color:#6f42c1;">부화 시작</button>`;
                } else {
                    abilityContent = `<h4>사용할 수 있는 특별한 능력이 없습니다.</h4><p>'내 미션' 탭을 확인하여 탐사대의 공동 임무를 해결하거나, 적의 임무를 방해하세요!</p>`;
                }
            }

            const rolesInGame = [...new Set(room.players.map(p => p.role))].sort();
            const roleSummary = rolesInGame.map(role => {
                const total = room.players.filter(p => p.role === role).length;
                const alive = room.players.filter(p => p.role === role && p.status === 'alive').length;
                return `<tr><td>${role}</td><td>${alive} / ${total}</td></tr>`;
            }).join('');
            const situationBoardContent = `<h4>직업별 생존 현황</h4><table class="summary-table"><thead><tr><th>직업</th><th>생존/총원</th></tr></thead><tbody>${roleSummary}</tbody></table>`;

            let missionContent = '';
            if (room.missionBoard) {
                const progressPercent = Math.round(room.missionBoard.progress * 100);
                const problemsHtml = room.missionBoard.problems.map((p, index) => {
                    let content = `<strong>${index + 1}</strong>`;
                    let solvedName = '';
                    if (p.status === 'solved') {
                        solvedName = `<span class="mission-solver-name">${p.solvedBy} 해결!</span>`;
                    } else if (p.status === 'failed') {
                        solvedName = `<span class="mission-solver-name">${p.failedBy} 실패</span>`;
                    }
                    return `<div class="mission-item ${p.status}" data-problem-index="${index}">${content}${solvedName}</div>`;
                }).join('');

                missionContent = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3>미션 보드 (80% 이상 해결 시 위기 저지)</h3>
            <h3 style="color: #00d1ff;">진행률: ${progressPercent}%</h3>
        </div>
        <div class="mission-board-grid">${problemsHtml}</div>
    `;
            } else {
                missionContent = '<h4>이번 게임에는 미션 보드가 활성화되지 않았습니다.</h4>';
            }

            const fakeCaptainUI = `
        <h4>능력 사용: 즉결 처분</h4>
        <p>의심되는 대상을 선택하여 즉결 처분을 진행합니다. 이 행동은 되돌릴 수 없습니다.</p>
        <ul class="player-grid-list">
            <li><button class="target-btn" disabled>참가자 A</button></li>
            <li><button class="target-btn pre-selected" disabled>참가자 B</button></li>
            <li><button class="target-btn" disabled>참가자 C</button></li>
            <li><button class="target-btn" disabled>참가자 D</button></li>
            <li><button class="target-btn" disabled>참가자 E</button></li>
        </ul>
        <p style="margin-top:15px; color:#888; font-size:0.9em;">(위장 화면입니다. 실제 기능은 동작하지 않습니다.)</p> 
    `;
            const fakePsychicUI = `
        <h4>능력 사용: 꿰뚫어보기</h4>
        <p>정체를 확인할 대상 4명을 선택하고 있습니다. 잠시만 기다려주세요...</p>
        <ul class="player-grid-list">
            <li><button class="target-btn pre-selected" disabled>참가자 A</button></li>
            <li><button class="target-btn pre-selected" disabled>참가자 B</button></li>
            <li><button class="target-btn" disabled>참가자 C</button></li>
            <li><button class="target-btn pre-selected" disabled>참가자 D</button></li>
            <li><button class="target-btn" disabled>참가자 E</button></li>
        </ul>
        <p style="margin-top:15px; color:#888; font-size:0.9em;">(위장 화면입니다. 실제 기능은 동작하지 않습니다.)</p>
    `;

            const camouflageContent = Math.random() < 0.5 ? fakeCaptainUI : fakePsychicUI;

            playerContainer.innerHTML = `
        <h2>${room.day}일차 밤: 탐사대 활동</h2>
        <div class="tab-container">
            <button class="tab-link active" data-tab="ability">내 능력</button>
            <button class="tab-link" data-tab="lobby">대기실</button>
            <button class="tab-link" data-tab="situation">상황판</button>
            <button class="tab-link" data-tab="mission">내 미션</button>
            <button class="tab-link" data-tab="camouflage">위장 화면</button> 
        </div>
        <div class="content-container">
            <div id="ability-content" class="tab-content active">${abilityContent}</div>
            <div id="lobby-content" class="tab-content"></div>
            <div id="situation-content" class="tab-content">${situationBoardContent}</div>
            <div id="mission-content" class="tab-content">${missionContent}</div>
            <div id="camouflage-content" class="tab-content">${camouflageContent}</div>
        </div>
    `;
            document.querySelectorAll('.tab-link').forEach(button => {
                button.addEventListener('click', () => {
                    const selectedTab = button.dataset.tab;
                    currentTab = selectedTab; // ✅ 현재 탭 저장
                    document.querySelectorAll('.tab-link').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));

                    button.classList.add('active');
                    document.getElementById(`${selectedTab}-content`).classList.add('active');
                });
            });
            showLobby(room, playerContainer.querySelector('#lobby-content'), { showGroup: false });
        }


        function showEngineerChoiceScreen(isEngineer) {
            clearContainer();
            const fightButtonAttr = isEngineer ? 'data-choice="fight"' : 'data-fake-button="true"';
            const escapeButtonAttr = isEngineer ? 'data-choice="escape"' : 'data-fake-button="true"';
            const fightButton = `<button ${fightButtonAttr} style="width: 45%; background-color: #28a745;">계속 싸운다</button>`;
            const escapeButton = `<button ${escapeButtonAttr} style="width: 45%; background-color: #dc3545;">비상탈출 가동</button>`;
            const notice = isEngineer
                ? `('계속 싸운다' 선택 시 '여왕의 만찬'이, '비상탈출' 선택 시 '인원 분배'의 위기가 찾아올 수 있습니다.)`
                : `엔지니어가 중대한 결정을 내리고 있습니다.`;
            playerContainer.innerHTML = `
                <h2>함장이 사망했습니다.</h2>
                <p>탐사대의 운명을 결정할 선택의 시간입니다. 엔지니어는 결정을 내려주세요.</p>
                <div style="margin-top: 30px; display: flex; gap: 20px; justify-content: center;">
                    ${fightButton}
                    ${escapeButton}
                </div>
                <p style="font-size: 0.9em; margin-top: 20px;">${notice}</p>
            `;
        }

        function showFeastAnnouncedScreen() {
            clearContainer();
            playerContainer.innerHTML = `
        <h2 style="color: #dc3545;">경고: 함선 전체 비상사태</h2>
        <p>엔지니어의 결정으로, 탐사대는 후퇴 대신 저항을 선택했습니다.</p>
        <p style="font-size: 1.2em; color: #ff4757; font-weight: bold; margin-top: 20px;">
            모두 엎드리세요! 여왕이 광란 상태에 빠졌습니다.<br>
            곧 여왕의 만찬이 시작됩니다.
        </p>
        <p style="margin-top: 20px;">관리자가 만찬을 시작하기를 기다립니다...</p>
    `;
        }

        function showEscapeSelectionAnnouncement() {
            clearContainer();
            playerContainer.innerHTML = `
        <h2>비상탈출 인원 선정</h2>
        <p style="font-size: 1.2em; margin-top: 20px;">이제 탐사선의 운명이 걸린 마지막 선택의 시간입니다.</p>
        <p>생존자들은 회의를 통해 캡슐에 탑승할 4명을 선정해야 합니다.</p>
        <div style="margin-top:25px; padding: 15px; border: 1px solid #ffc107; border-radius: 5px; background-color: rgba(255, 193, 7, 0.1);">
            <h4 style="margin-top:0; color: #ffc107;">주의사항</h4>
            <ul style="text-align: left; margin: 10px auto; max-width: 400px;">
                <li><b style="color: #28a745;">군인, 엔지니어, 의사</b>가 없으면 위기가 찾아옵니다.</li>
                <li><b style="color: #dc3545;">뚱이, 에일리언</b>이 탑승하면 위기가 찾아옵니다.</li>
            </ul>
        </div>
        <h1 class="timer" id="timer-display" style="margin-top: 30px;">03:30</h1>
    `;
        }

        function typewriter(element, text, speed = 50, callback) {
            let i = 0;
            element.innerHTML = '';
            const cursor = document.createElement('span');
            cursor.className = 'typing-cursor';
            element.appendChild(cursor);

            function type() {
                if (i < text.length) {
                    element.insertBefore(document.createTextNode(text.charAt(i)), cursor);
                    i++;
                    setTimeout(type, speed);
                } else {
                    if (cursor.parentNode) {
                        cursor.parentNode.removeChild(cursor);
                    }
                    if (callback) callback();
                }
            }
            type();
        }

        function showEscapeSequenceScreen(room) {
            const containerId = 'escape-log-container';
            let container = document.getElementById(containerId);

            if (!container) {
                clearContainer();
                playerContainer.innerHTML = `
                <h2 style="color: #ffc107;">비상탈출 시퀀스 가동 중</h2>
                <p>생존을 위한 마지막 관문들을 통과해야 합니다.</p>
                <div id="${containerId}" style="text-align: left; margin-top: 20px; padding: 15px; border: 1px solid #666; background-color: #222; border-radius: 5px; height: 250px; overflow-y: auto; font-family: 'Courier New', Courier, monospace; color: #00ff41;">
                </div>
                <p style="margin-top: 20px;">관리자가 다음 단계를 진행하기를 기다립니다...</p>
            `;
                container = document.getElementById(containerId);
                displayedLogCount = 0;
            }

            const logs = room.escapeLog || [];
            if (logs.length > displayedLogCount) {
                const newLogs = logs.slice(displayedLogCount);

                function printNextLog(index = 0) {
                    if (index < newLogs.length) {
                        const logEntry = document.createElement('p');
                        logEntry.style.margin = '0 0 5px 0';
                        container.appendChild(logEntry);
                        container.scrollTop = container.scrollHeight;

                        typewriter(logEntry, newLogs[index], 30, () => {
                            printNextLog(index + 1);
                        });
                    }
                }

                printNextLog();
                displayedLogCount = logs.length;
            }
        }

        socket.on('connect', () => console.log('서버에 성공적으로 연결되었습니다.'));

        socket.on('updateRoom', (room) => {
            // ★★★ [수정] 이 한 줄을 추가해야 클릭이 동작합니다. ★★★
            gameRoomsState[currentRoomCode] = room;

            console.log('클라이언트가 서버로부터 받은 room 데이터:', room);
            const headerContainer = document.getElementById('header-container');
            if (headerContainer) headerContainer.innerHTML = '';

            const meForHeader = room.players.find(p => p.id === socket.id);
            if (meForHeader && meForHeader.group) {
                const myGroupMembers = room.players
                    .filter(p => p.status === 'alive' && p.group === meForHeader.group)
                    .map(p => p.name)
                    .join(', ');

                if (!headerContainer) {
                    const newHeader = document.createElement('div');
                    newHeader.id = 'header-container';
                    playerContainer.before(newHeader);
                }
                document.getElementById('header-container').innerHTML = `
            <div class="group-info-header">
                <strong> (${meForHeader.group}모둠):</strong> ${myGroupMembers}
            </div>
        `;
            }
            if (!amIAlive || room.status === 'game_over') return;

            const me = room.players.find(p => p.id === socket.id);
            if (!me) {
                adminContainer.style.display = 'block';
                showInitialScreen();
                return;
            } else {
                adminContainer.style.display = 'none';
            }

            if (room.pendingAction === 'engineer_choice') {
                const isEngineer = me.role === '엔지니어';
                showEngineerChoiceScreen(isEngineer);
                return;
            }

            if (room.pendingAction === 'escape_survivor_selection') {
                showEscapeSelectionAnnouncement();
                return;
            }

            if (room.pendingAction === 'queen_rampage') {
                if (me.role !== '에일리언 여왕') {
                    showFeastAnnouncedScreen();
                }
                else if (!room.rampageTriggered) {
                    showFeastAnnouncedScreen();
                }
                return;
            }

            if (room.status === 'playing') {
                switch (room.phase) {
                    case 'role_reveal':
                        showRoleScreen(me.role, me.description);
                        break;
                    case 'meeting':
                        showMeetingScreen(room, me);
                        break;
                    case 'night_alien_action':
                        if (!room.alienActionTriggered) {
                            showAlienNightScreen("밤이 되었습니다. 모두 눈을 감아주세요.");
                        }
                        break;
                    case 'night_crew_action':
                        showCrewActionScreen(room);
                        break;
                    case 'escape_sequence':
                        showEscapeSequenceScreen(room);
                        break;
                    default:
                        showLobby(room, playerContainer);
                        break;
                }
            } else if (room.status === 'waiting') {
                showLobby(room, playerContainer);
            } else {
                showInitialScreen();
            }
            const activeButton = document.querySelector(`.tab-link[data-tab="${currentTab}"]`);
            if (activeButton) activeButton.click();
        });

        socket.on('youAreDead', () => { amIAlive = false; showDeathScreen(); });
        socket.on('youAreAlive', () => { amIAlive = true; alert('당신은 부활했습니다!'); });
        socket.on('gameOver', (data) => showGameOverScreen(data));
        socket.on('endingSequenceStart', (data) => {
            clearContainer();
            playerContainer.innerHTML = `
        <div id="ending-reason-container" style="font-size: 1.5em; line-height: 1.8;"></div>
    `;
            const reasonContainer = document.getElementById('ending-reason-container');
            typewriter(reasonContainer, data.reason, 50);
        });
        socket.on('alienAction', (data) => {
            if (!amIAlive || data.targets.length === 0) return;
            clearContainer();
            const targetButtons = data.targets.map(target => `<li><button class="target-btn" data-ability="alien" data-target-id="${target.id}">${target.name}</button></li>`).join('');
            playerContainer.innerHTML = `<h2>오늘 밤의 사냥감을 선택하세요.</h2>
                <p>${data.otherAliens.length > 0 ? `(동료 에일리언: ${data.otherAliens.join(', ')})` : '(동료 에일리언 없음)'}</p>
                <ul class="player-grid-list">${targetButtons}</ul>`;
        });

        socket.on('abilityError', (message) => {
            alert(message);
        });

        socket.on('nightSelectionUpdate', (data) => {
            if (!amIAlive) return;
            const allSelectedTargetIds = new Set(Object.values(data.selections).flat());
            document.querySelectorAll('.target-btn').forEach(btn => {
                btn.classList.toggle('pre-selected', allSelectedTargetIds.has(btn.dataset.targetId));
            });
        });

        socket.on('timerUpdate', (data) => {
            if (!amIAlive) return;
            const timerDisplay = document.getElementById('timer-display');
            if (timerDisplay) {
                const timeLeft = data.timeLeft;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = (timeLeft % 60).toString().padStart(2, '0');
                timerDisplay.textContent = (timeLeft >= 0) ? `${minutes}:${seconds}` : "회의 종료!";
            }
        });

        function showRouletteScreen(data) {
            const oldOverlay = document.getElementById('roulette-overlay');
            if (oldOverlay) oldOverlay.remove();

            const overlay = document.createElement('div');
            overlay.id = 'roulette-overlay';

            let cardsHtml = '';
            data.options.forEach((option, index) => {
                cardsHtml += `
            <div class="roulette-card is-shuffling" data-result="${option.back}">
                <div class="card-flipper">
                    <div class="card-shuffler" style="animation-delay: ${index * 0.25}s">
                        <div class="card-face card-front">${option.front}</div>
                        <div class="card-face card-back">${option.back}</div>
                    </div>
                </div>
            </div>
        `;
            });

            overlay.innerHTML = `<h1>${data.title}</h1><div id="roulette-container">${cardsHtml}</div>`;
            document.body.appendChild(overlay);
        }

        socket.on('showRoulette', (data) => {
            showRouletteScreen(data);
        });

        socket.on('rouletteResult', (data) => {
            document.querySelectorAll('.roulette-card').forEach(card => {
                card.classList.remove('is-shuffling');
            });

            const cardToReveal = document.querySelector(`.roulette-card[data-result="${data.result}"]`);
            if (cardToReveal) {
                setTimeout(() => {
                    cardToReveal.classList.add('is-flipped');
                }, 200);
            }
        });

        socket.on('globalAlert', (data) => {
            alert(`[알림: ${data.title}]\n\n${data.message}`);
        });

        socket.on('missionResult', (data) => {
            alert(data.message);
        });

        socket.on('queenHuntAction', (data) => {
            if (amIAlive) {
                showQueenHuntScreen(data.otherAliens, data.targets);
            }
        });

        socket.on('feastAnnounced', () => {
            console.log("Feast Announced event received!");
            if (amIAlive) {
                isEngineerChoiceActive = false;
                showFeastAnnouncedScreen();
            }
        });

        socket.on('queenRampageAction', (data) => {
            console.log("Queen Rampage Action event received!");
            if (amIAlive) {
                showQueenRampageScreen(data.targets);
            }
        });

        socket.on('actionConfirmed', () => {
            console.log("Action Confirmed event received!");
            if (amIAlive) {
                showAlienNightScreen("선택이 완료되었습니다. 다른 에일리언들을 기다립니다.");
            }
        });

        socket.on('hideRoulette', () => {
            const overlay = document.getElementById('roulette-overlay');
            if (overlay) {
                overlay.remove();
            }
        });

        document.addEventListener('click', function (event) {
            const target = event.target;
            const closestMissionItem = target.closest('.mission-item');

            if (target.id === 'join-button') {
                const nameInput = document.getElementById('name-input');
                const codeInput = document.getElementById('code-input');
                if (nameInput.value.trim() && codeInput.value.trim()) {
                    currentRoomCode = codeInput.value.trim();
                    socket.emit('joinGame', { name: nameInput.value, code: currentRoomCode });
                } else { alert('이름과 초대 코드를 모두 입력해주세요.'); }
                return;
            }

            if (target.id === 'admin-button') {
                window.location.href = '/admin';
                return;
            }

            if (closestMissionItem) {
                const room = gameRoomsState[currentRoomCode];
                if (!room || !room.crewActionTriggered) return;

                if (!closestMissionItem.classList.contains('unsolved')) {
                    return;
                }
                const problemIndex = closestMissionItem.dataset.problemIndex;
                const problem = room.missionBoard.problems[problemIndex];

                if (problem) {
                    document.getElementById('mission-question').textContent = problem.question;
                    document.getElementById('mission-answer-input').value = '';
                    document.getElementById('mission-submit-btn').dataset.problemIndex = problemIndex;
                    document.getElementById('mission-modal').style.display = 'flex';
                    document.getElementById('mission-answer-input').focus();
                }
                return;
            }

            if (target.id === 'mission-submit-btn') {
                const problemIndex = target.dataset.problemIndex;
                const answerInput = document.getElementById('mission-answer-input');
                if (answerInput.value) {
                    socket.emit('submitMissionAnswer', { problemIndex: problemIndex, answer: answerInput.value });
                    document.getElementById('mission-modal').style.display = 'none';
                }
                return;
            }

            if (target.id === 'mission-close-btn') {
                document.getElementById('mission-modal').style.display = 'none';
                return;
            }


            if (target.classList.contains('tab-link')) {
                const tabName = target.dataset.tab;
                playerContainer.querySelectorAll('.tab-link').forEach(btn => btn.classList.remove('active'));
                playerContainer.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                target.classList.add('active');
                playerContainer.querySelector(`#${tabName}-content`).classList.add('active');
                return;
            }

            else if (target.classList.contains('group-select-btn')) {
                const groupNumber = target.dataset.group;
                socket.emit('selectGroup', { roomCode: currentRoomCode, groupNumber: groupNumber });
                document.querySelectorAll('.group-select-btn').forEach(btn => btn.disabled = true);
                target.style.backgroundColor = '#28a745';
                target.textContent = '선택 완료';
                return;
            }

            if (target.dataset.choice) {
                if (target.dataset.choice === 'fight') {
                    if (confirm("'계속 싸운다'를 선택하면 큰 위험이 따를 수 있습니다. 정말 선택하시겠습니까?")) {
                        socket.emit('engineerChoseToFight');
                    }
                } else if (target.dataset.choice === 'escape') {
                    if (confirm("비상탈출을 시작하면 돌이킬 수 없습니다. 정말 가동하시겠습니까?")) {
                        socket.emit('engineerChoseEscape');
                    }
                }
                return;
            }
            else if (target.dataset.fakeButton) {
                alert('엔지니어만 이 결정을 내릴 수 있습니다.');
                return;
            }

            if (target.id === 'confirm-hunt-btn') {
                if (huntSelections.length === 2) {
                    socket.emit('useQueenHunt', { targetIds: huntSelections });
                    target.textContent = '선택 완료';
                    target.disabled = true;
                }
                return;
            }

            if (target.id === 'confirm-rampage-btn') {
                socket.emit('useQueenRampage', { targetIds: huntSelections });
                target.textContent = '선택 완료';
                target.disabled = true;
                return;
            }

            if (target.id === 'start-hatch-btn') {
                if (confirm('부화를 시작하면 돌이킬 수 없습니다. 진행하시겠습니까?')) {
                    socket.emit('useAlienEggAbility');
                    target.textContent = '부화 진행 중...';
                    target.disabled = true;
                }
                return;
            }

            if (target.id === 'confirm-psychic-ability') {
                if (huntSelections.length === 4) {
                    socket.emit('usePsychicAbility', { targetIds: huntSelections });
                    target.textContent = '능력 사용됨';
                    target.disabled = true;
                }
                return;
            }

            if (target.classList.contains('target-btn')) {
                const abilityType = target.dataset.ability;
                const targetId = target.dataset.targetId;
                const targetName = target.textContent;

                if (abilityType === 'queen_hunt') {
                    const confirmBtn = document.getElementById('confirm-hunt-btn');
                    const index = huntSelections.indexOf(targetId);
                    if (index > -1) {
                        huntSelections.splice(index, 1);
                        target.classList.remove('pre-selected');
                    } else {
                        if (huntSelections.length < 2) {
                            huntSelections.push(targetId);
                            target.classList.add('pre-selected');
                        }
                    }
                    confirmBtn.textContent = `선택 완료 (${huntSelections.length}/2)`;
                    confirmBtn.disabled = huntSelections.length !== 2;
                    return;
                }

                if (abilityType === 'queen_rampage') {
                    const confirmBtn = document.getElementById('confirm-rampage-btn');
                    const index = huntSelections.indexOf(targetId);
                    if (index > -1) {
                        huntSelections.splice(index, 1);
                        target.classList.remove('pre-selected');
                    } else {
                        if (huntSelections.length < 4) {
                            huntSelections.push(targetId);
                            target.classList.add('pre-selected');
                        }
                    }
                    confirmBtn.textContent = `선택 완료 (${huntSelections.length}명)`;
                    return;
                }

                if (abilityType === 'psychic') {
                    const confirmBtn = document.getElementById('confirm-psychic-ability');
                    const index = huntSelections.indexOf(target.dataset.targetId);
                    if (index > -1) {
                        huntSelections.splice(index, 1);
                        target.classList.remove('pre-selected');
                    } else {
                        if (huntSelections.length < 4) {
                            huntSelections.push(target.dataset.targetId);
                            target.classList.add('pre-selected');
                        }
                    }
                    confirmBtn.textContent = `선택 완료 (${huntSelections.length}/4)`;
                    confirmBtn.disabled = huntSelections.length !== 4;
                    return;
                }

                if (confirm(`${targetName}님을 대상으로 능력을 사용하시겠습니까?`)) {
                    switch (abilityType) {
                        case 'alien':
                            socket.emit('nightAction', { targetId: target.classList.contains('pre-selected') ? null : targetId });
                            break;
                        case 'soldier':
                            socket.emit('useSoldierAbility', { targetId });
                            break;
                        case 'captain':
                            socket.emit('useCaptainAbility', { targetId });
                            break;
                        case 'chatterbox':
                            socket.emit('useChatterboxAbility', { targetId });
                            break;
                    }
                }
            }
        });
    </script>
</body>

</html>

</script>
<div id="mission-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <button id="mission-close-btn" class="modal-close-btn">&times;</button>
        <h3 id="mission-question"></h3>
        <input type="text" id="mission-answer-input" placeholder="정답을 입력하세요...">
        <button id="mission-submit-btn" class="modal-submit-btn">정답 제출</button>
    </div>
</div>
</body>

</html>